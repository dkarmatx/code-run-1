#include <algorithm>
#include <cstdint>
#include <iostream>
#include <vector>

namespace common {
    template <typename Value>
    auto getFromStdin() -> Value {
        Value var;
        std::cin >> var;
        if (!std::cin.good()) {
            throw std::runtime_error("Failed to read value from stdin");
        }
        return var;
    }
}  // namespace common

namespace solution {
    // Так как конь может ходить только влево и вниз, то есть ограниченное количество
    // точек на которые он может походить на карте.
    //
    // Распишем пример такой карты
    //
    // 1 a a b b b c c
    // a a 1 b b c c c
    // a 1 b b 1 c c d
    // b b b 2 c c 1 d
    // b b 1 c c 3 d d
    // b c c c 3 d d 4
    // c c c 1 d d 6 e
    // c c d d d 4 e e
    //
    // На буквы пока можно не обращаться внимание, пояснение будет ниже...
    // Числами на карте отмечены те места куда может добраться конь, и
    // сколько путей существует в ту или иную точку. В места почеменые буквами
    // конь добраться не может.
    //
    // Давайте посмотрим на то как высчитывается количество ходов для той
    // или инной точки, для этого удобно посмотреть на это со стороны такого дерева:
    //
    // level:
    // 1       1
    //         |\
    // 2       1  1
    //         |\ |\
    // 3       1  2  1
    //         |\ |\ |\
    // 4       1  3  3  1
    //         |\ |\ |\ |\
    // 5       1  4  6  4  1
    // ...
    //
    // Каждый узел хранит в себе сумму родительских узлов, на
    // каждом уровне глубины, количество узлов (а значит и возможных точек для хода)
    // равно значению уровня.
    //
    // Теперь стоит обратить внимание на то как расположены буквы на карте. Можем заметить
    // что они лежат на одних и тех же диагоналях карты. Числа тоже относятся к соответствующим
    // диагоналям. Номер зоны, равен количеству достижимых точек которые находятся в этой зоне.
    // А так-же номер каждой зоны связан с номером уровня в нашем представленном дереве.
    //
    // Соотвественно если мы знаем точку для которой нам надо расчитать количество маршрутов,
    // Все что нам надо сделать, это расчитать количество маршрутов для определенного уровня
    // в дереве. Расчитать координаты точек соответсвующих вершинам этого среза дерева. А затем
    // найти среди точек нужную, если она там есть.
    // 
    // Если искомой точки нету в срезе, соответсвующему определенной зоне на карте, значит
    // в такой точке количество маршрутов равно 0.
    //
    auto solve(const std::uint64_t hieght, const std::uint64_t width) -> std::uint64_t {
        using Point = std::tuple<std::uint64_t, std::uint64_t>;

        // Номер зоны определить легко. ((x + y) / 3) + 1, где x=w-1, а y=h-1
        const std::uint64_t diagonale_level = (hieght + width - 2) / 3 + 1;

        // Можно обратить внимание что у крайних точек среза одна из координат равна level-1, а
        // другая равна (level-1) * 2. Находим такую точку, а зная какое их количество в срезе,
        // мы просто расчитываем последующие точки двигаясь диагонально
        std::vector<Point> possible_points(
            diagonale_level,
            {diagonale_level-1u, (diagonale_level-1u) * 2u});
        for (size_t i = 1; i < diagonale_level; ++i) {
            auto [prev_x, prev_y] = possible_points[i-1];
            possible_points[i] = {prev_x+1, prev_y-1};
        }

        // Количество маршрутов для точек среза считаем с помощью метода
        // мемоизации. Суммируем значения для предыдущих точек и получаем
        // нужный нам уровень
        std::vector<std::uint64_t> path_counts(diagonale_level, 1);
        for (size_t h = 2; h < diagonale_level; ++h) {
            auto prev_path_counts = path_counts;
            for (size_t i = 1; i < h; ++i) {
                path_counts[i] = prev_path_counts[i-1] + prev_path_counts[i];
            }
        }

        // Так как все точки и значения их маршрутов лежат в порядке возрастания
        // координаты x, находим при помощи бинарного поиска нужную нам точку, если
        // такая кончено же имеется. Иначе считаем что количество маршрутов равно 0
        auto point_to_find = Point{width-1, hieght-1};
        auto res = std::lower_bound(
            possible_points.begin(),
            possible_points.end(),
            point_to_find,
            [](const Point& a, const Point& b) {
                const auto [ax, _1] = a;
                const auto [bx, _2] = b;
                return ax < bx;
            });
        if (res != possible_points.end() && *res == point_to_find) {
            return path_counts[std::distance(possible_points.begin(), res)];
        }
        // Для расчета временной сложности используем:
        // d = (w-1 + h-1) / 3 + 1
        //
        // Этап с вычисление точек для среза по сложности равен: O(d)
        // 
        // Этап с вычислением маршрутов для точек в срезе по сложности равен:
        // O(1 + 2 + 3 + ... + d) = O( (2d+(d-1))/2 * d ) = O(d*d)
        //
        // Этап с поиском нужной точки по сложности равен: O(log(d))
        return 0;
    }
}  // namespace solution

// https://coderun.yandex.ru/problem/knight-move
//
// Условия задачи:
//
// Дана прямоугольная доска N×M (N строк и M столбцов). В левом верхнем углу
// находится шахматный конь, которого необходимо переместить в правый
// нижний угол доски. В данной задаче конь может перемещаться на две клетки вниз
// и одну клетку вправо или на одну клетку вниз и две клетки вправо.
//
// Необходимо определить, сколько существует различных маршрутов, ведущих из
// левого верхнего в правый нижний угол.
//
// Пример ввода:
// > 31 34
//
// Пример вывода:
// > 293930

auto main() -> int {
    const auto height = common::getFromStdin<std::uint64_t>();
    const auto width = common::getFromStdin<std::uint64_t>();

    std::cout << solution::solve(height, width) << std::endl;
}